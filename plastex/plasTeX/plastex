#!/usr/bin/env python

import os, sys, codecs, string, glob
import plasTeX
from plasTeX.TeX import TeX
from plasTeX.Config import config
from plasTeX.ConfigManager import *
from plasTeX.Logging import getLogger

log = getLogger()

__version__ = '0.9.3'

def main(argv):
    """ Main program routine """
    print >>sys.stderr, 'plasTeX version %s' % __version__

    # Parse the command line options
    try: 
        opts, args = config.getopt(argv[1:])
    except Exception, msg:
        log.error(msg)
        print >>sys.stderr, config.usage()
        sys.exit(1)

    if not args:
        print >>sys.stderr, config.usage()
        sys.exit(1)

    file = args.pop(0)

    # Create document instance that output will be put into
    document = plasTeX.TeXDocument(config=config)

    # Instantiate the TeX processor and parse the document
    tex = TeX(document, file=file)

    # Populate variables for use later
    if config['document']['title']:
        document.userdata['title'] = config['document']['title']
    jobname = document.userdata['jobname'] = tex.jobname
    cwd = document.userdata['working-dir'] = os.getcwd()

    # Load aux files for cross-document references
    pauxname = '%s.paux' % jobname
    rname = config['general']['renderer']
    for dirname in [cwd] + config['general']['paux-dirs']:
        for fname in glob.glob(os.path.join(dirname, '*.paux')):
            if os.path.basename(fname) == pauxname:
                continue
            document.context.restore(fname, rname)

    # Parse the document
    tex.parse()

    # TODO(downey): where is the right place to add this hook?
    # Are these changes right for all Renderers, or are they DocBook
    # specific?
    cleaner = TreeCleaner(tex, document)

    # Set up TEXINPUTS to include the current directory for the renderer
    os.environ['TEXINPUTS'] = '%s%s%s%s' % (os.getcwd(), os.pathsep,
                                         os.environ.get('TEXINPUTS',''), os.pathsep)

    # Change to specified directory to output to
    outdir = config['files']['directory']
    if outdir:
        outdir = string.Template(outdir).substitute({'jobname':jobname})
        if not os.path.isdir(outdir):
            os.makedirs(outdir)
        log.info('Directing output files to directory: %s.' % outdir)        
        os.chdir(outdir)
    
    # Load renderer
    try: 
        exec('from plasTeX.Renderers.%s import Renderer' % rname)
    except ImportError, msg:
        log.error('Could not import renderer "%s".  Make sure that it is installed correctly, and can be imported by Python.' % rname)
        sys.exit(1)

    # Write expanded source file
    #sourcefile = '%s.source' % jobname
    #open(sourcefile,'w').write(document.source.encode('utf-8'))
    
    # Write XML dump
    if config['general']['xml']:
        outfile = '%s.xml' % jobname
        codecs.open(outfile,'w',encoding='utf-8').write(document.toXML())
    
    # Apply renderer
    Renderer().render(document)

    print


class TreeCleaner(object):
    def __init__(self, tex, document):
        self.tex = tex
        self.document = document
        self.clean()

    def clean(self):
        """Walk the node tree fixing problems.

        tex:
        document: TeXDocument
        """
        fp = codecs.open('plastex.before', 'w', encoding='utf-8')
        fp.write(self.document.toXML())
        fp.close()

        print '-----------------------'
        self.walk(self.document, self.test_node)
        print '-----------------------'

        fp = codecs.open('plastex.after', 'w', encoding='utf-8')
        fp.write(self.document.toXML())
        fp.close()

    def walk(self, node, func):
        """Walks a node tree and invokes a function on each node.

        node: Node
        func: function object
        """
        for child in node.childNodes:
            self.walk(child, func)
        func(node)

    def test_node(self, node):
        """Checks for problems and fixes them.

        Checks for things that should not be embedded in par.

        node: Node
        """
        self.test_par(node)
        self.test_quote(node)
        self.test_figure(node)
        self.test_math(node)

    def test_math(self, node):
        """Checks for math tags we can convert to mathphrases.

        node: Node
        """
        if node.nodeName != 'math':
            return

        print 'before'
        self.print_tree(node, '')

        children = node.childNodes

        if len(children) == 1:
            child = children[0]
            if child.nodeName == '#text':
                phrase = self.document.createElement('mathphrase')
                phrase.append(child)
                self.replace(node, [phrase])

                print 'after'
                self.print_tree(phrase, '')

    def test_figure(self, node):
        """Checks for bad paragraphs inside figures.

        node: Node
        """
        if node.nodeName != 'figure':
            return

        # if the first node is a par, unpack it
        child = node.firstChild
        if child.nodeName != 'par':
            return

        self.unpack(child)

    def test_quote(self, node):
        """Checks for quote text not wrapped in a paragraph.

        node: Node
        """
        if node.nodeName not in ['quote', 'quotation', 'exercise']:
            return

        children = node.childNodes
        child = children[0]
        if child.nodeName == 'par':
            return

        # if the quote contains bare text, wrap it in a par
        par = self.document.createElement('par')
        par.extend(children)
        while node.childNodes:
            node.pop(-1)
        node.insert(0, par)

    def print_node(self, node):
        print node.nodeName
        for child in node.childNodes:
            print '    ', child.nodeName

    def print_tree(self, node, prefix):
        if node.nodeName == '#text':
            print prefix + node
        else:
            print prefix + node.nodeName

        for child in node.childNodes:
            self.print_tree(child, prefix + '   ')

    def test_par(self, node):
        """Checks for things that should not be embedded in par.

        node: Node
        """
        if node.nodeName != 'par':
            return

        children = node.childNodes
        if len(children) == 0:
            return

        first = children[0]
        if first.nodeName == '#text':
            return

        # list of nodeNames that should not be embedded in par
        bad_names = set(['itemize', 'description', 'enumerate', 'quote',
                         'verbatim', 'par', 'figure', 'centerline', 'label'])

        if first.nodeName not in bad_names:
            print 'Allowing embedded', first.nodeName
            return

        self.replace(node, children)

    def unpack(self, node):
        """Replaces a node with its children.

        node: Node
        """
        self.replace(node, node.childNodes)

    def replace(self, child, replacements):
        """Replaces a node with a list of nodes.

        Modifies the parent of child.

        child: Node
        replacement: list of Nodes
        """
        parent = child.parentNode
        for i, node in enumerate(parent):
            if node == child:
                parent.pop(i)
                for j, replacement in enumerate(replacements):
                    parent.insert(i+j, replacement)
                return
        raise ValueError('Child not found.')



def info(type, value, tb):
   if hasattr(sys, 'ps1') or not sys.stderr.isatty():
      # we are in interactive mode or we don't have a tty-like
      # device, so we call the default hook
      sys.__excepthook__(type, value, tb)
   else:
      import traceback, pdb
      # we are NOT in interactive mode, print the exception...
      traceback.print_exception(type, value, tb)
      print
      # ...then start the debugger in post-mortem mode.
      pdb.pm()

#sys.excepthook = info

#sys.setrecursionlimit(10000)
    
#main(sys.argv)
try:
    main(sys.argv)
except KeyboardInterrupt:
    pass
